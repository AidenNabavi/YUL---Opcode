assembly{

    //stop
    stop()
    //اجرای قرارداد رو بلافاصله متوقف می‌کنه و بدون هیچ داده‌ای بازگشت () می‌زنه
    


    //add
    let result := add(2, 3)
    //شرح: جمع دو عدد بالای استک را انجام می‌دهد.
    //a+b
    // دو مقدار از استک برمی‌دارد، جمع می‌کند، نتیجه را روی استک می‌گذارد.
    


    //mul
    let result := mul(4, 5) // result = 20
    //a*b




    //منها
    //sub
    let result := sub(10, 4) // result = 6
    //a-b





    //تقسیم
    //div                     sdiv
    let result := div(9, 2) // result = 4






    //mod           smod
    //باقی‌مانده تقسیم برای اعداد علامت دار
    //a%b
    let result := mod(10, 3) // result = 1






// علامت دارد  یعنی علامت عدد اول رو قرار میده در خروجی 
// smod(-10, 3) = -1

    //addmod(x, y, k)
    // (a + b) % N
    let result := smod(-10, 3) // result = -1
 //همانند مد بالا ولی برای اعداد  (منفی/مثبت). نتیجه علامت عدد اول را نگه می‌دارد.
 // یعنی عدد اول اگر منفی بود جواب منفی و اگر مثبت بود برعکس 







    //mulmod(x, y, k)
    let result := mulmod(4, 7, 5) // (4*7) % 5 = 28 % 5 = 3
    //(a * b) % N

    	



    //توان
    EXP
    // let result := exp(2, 5) // 2 ** 5 = 32







//✏️ وظیفه: عددی که سایزش کوچیکه (مثلاً 1 بایت) رو به عدد 256 بیتی تبدیل می‌کنه با حفظ علامت منفی یا مثبت بودنش.
//🔑 علامت یه عدد کوچیک رو به یه عدد بزرگ‌تر می‌کشه. خلاصه 
    // مثلاً: SIGNEXTEND(0, 0xFF) → 0xFFFFFFFFFFFFFFFF...FF (منفی ۱)
    SIGNEXTEND
    let result := signextend(0, 0xFF) // result = -1 (0x...FF)
//signextend(b, x)
// b: شماره بایت که باید بیت علامتش بررسی بشه.
// x: مقدار ورودی که باید علامتش گسترش داده بشه.
// یعنی اگه عددت منفی باشه، بقیه بیت‌ها رو با ۱ پر می‌کنه → منفی بمونه.
// اگه مثبت باشه، بقیه رو با ۰ پر می‌کنه → مثبت بمونه.

//ایویام اعداد رو از راست به چپ (از کم‌ارزش‌ترین بایت) می‌خونه.
/*
بایت شماره 0 یعنی کم‌ارزش‌ترین بایت .

بایت شماره 1 یعنی دومین بایت از سمت راست.

بایت شماره 31 یعنی بیشترین بایت سمت چپ.

            

b → بایت علامت رو مشخص می‌کنه
x → عددیه که می‌خوای علامتش رو در کل ۲۵۶ بیت پخش کنی.
*/




    LT             
    //a<b
    let result := lt(3, 10) // true → 1

    SLT
        //a<b
        // با علامت این فقط
    let result := slt(-3, 1) // true → -1






    GT         
    //a>b
    let result := gt(9, 4) // true → 1

    //a>b
    SGT// علامت دار 
    let result := sgt(-1, -4) // true → -1






    EQ 
    // a ==b 
    let result := eq(7, 7) // true → 1






    ISZERO
    //a ==0
    let result := iszero(0) // result = 1








    AND
    // بیت به بیت میسنجه و خروجی میده 
    // اگر هر دو بیت یک باشن خروجی یک میدهد در غیر این صورت صفر 
    //a & b
    let result := and(0x0F, 0xF0) // 00001111 & 11110000 = 00000000
// الان در این اول این رو به بیت تبدلی میکنن تا مشخص شود بعد 
/*
هر دو عدد رو به بیت تبدیل می‌کنه

بیت به بیت AND منطقی انجام می‌ده


 در باینری کلا همینه همیشه هگزادسیمال به بیت تبدیل میشه بعد عملیات روشون انجام میشه 💀💀💀💀💀💀💀💀💀💀💀😉😉😉😉

*/





//برای بازیابی کلید  ادرس طرف کسی که امضا کرده است 
    erecover(hash,v,r,s);



    OR
    //    // بیت به بیت میسنجه و خروجی میده 
    // فقط اگر هر دو بیت  صفر باشن → خروجی صفر می‌شه. در غیر این صورت یک 
    //a | b
    let result := or(0x0F, 0xF0) // 00001111 | 11110000 = 11111111





// خیلی رراحتن به قران

    XOR 
    //عملیات XOR بیت به بیت
    //وقتی هر دو بیت دو طرف متفاوت باشن خروجی یک میشه در غیر این صورت صفر
    //a ^ b
    let result := xor(0x0F, 0xF0) // 00001111 ^ 11110000 = 11111111





    NOT 
    /*

هر بیت که 1 هست میشه 0

1هر بیت که 0 هست میشه 

    */
    //برعکس کردن بیت‌ها
    let result := not(0x00FF) // result = ~0x00FF = 0xFFFFFFFFFFFFFFFF...FF00
    //مثال
    let a := 0x0F         // 0000 1111 (در 8 بیت فرضی)
    let result := not(a)   // 1111 0000




    BYTE
    //بازیابی یک بایت مشخص از یک کلمه 
     //byte(index, value)
    /*
        index = شماره بایت موردنظر (از ۰ تا ۳۱)// شبیه ایندکس است یعین از یک تا سی یک هر اندکسی رو مشخص کنی از اون عدد دوم بیرون میکشه 

        value = عدد ۲۵۶ بیتی که می‌خوای ازش بایت بگیری
    */
    let result := byte(0, 0x1234567890abcdef000000000000000000000000000000000000000000000000)
    // result = 0x12






    SHL      
    //شیفت دادن بیت‌ها به چپ (value << shift)
    let result := shl(1, 0x01) // 0x01 << 1 = 0x02
    //shl(shift count , value)  مقداره     تعداد شیفت  
    let result := shl(3, 0x01) // 0x01 << 3 = 0x08 (00001000)   
    // اول به باینری تبدیل میشه // بعد سه تا صفر از راست اضافه میشود   
//وقتی شیفت به چپ می‌دی، یعنی بیت‌ها رو به چپ می‌کشی و از سمت راست سه تا صفر اضافه میشه.
//00000001  << 3  =>  00001000







    SAR
    //شیفت به راست  علامت دار
    let result := sar(1, -4) // -4 >> 1 = -2
    // وقتی شیفت به راست می‌دی، یعنی بیت‌ها رو به راست می‌کشی و از سمت چپ بهش عدد اضافه میشه. نه صفر
//11111100
//مثلا این 
//11111110






    //هش کردن محتویات از یک اندازه مشخص تا یک اندازه مشخص
    // ذخیره کردن 32 بایت داده در حافظه (memory)س
    //KECCAK256 
    //    mstore(value , مخل ذخیره سازی)
    mstore(0x00, 0x1234)
    let hash := keccak256(0x00, 32) // هش 32 بایت از offset صفر







    //ADDRESS
    //آدرس کانترکت جاری را برمی‌گرداند
    let addr := address()





    //BALANCE
    // موجودی () یک آدرس خاص رو برمی‌گردونه.
    let target := 0x1234567890abcdef1234567890abcdef12345678
    let bal := balance(target)






    CALLER
    //آدرس ارسال کننده مستقیم این فراخوانی
    //آدرس فراخواننده تابع (). در فرستنده در سالدیتی  همین است.
    let sender := caller()// ادرس سندر رو نشون میده  msg.sender






    //مقدار اتر که همراه کال یا تراکنش  ارسال شده.
    //معادل msg.value
    let val := callvalue()





    //32 بایت از مقدار وردی که به تابع داده اسم رو برمیگردونه
    // یعنی داده‌هایی که با تراکنش به کانترکت ارسال شدن.
    CALLDATALOAD()
    let value := calldataload(0x04) // معمولاً آرگومان اول از offset 0x04 شروع می‌شه





    CALLDATASIZE()
    //کل اندازه‌ی کالدیتا رو (به بایت) برمی‌گردونه.
    let size := calldatasize()





    CODESIZE()
    // سایز کد در حال اجرای کانترکت فعلی.
    //اندازه (تعداد بایت) کل کد قرارداد در بلاک‌چین رو برمی‌گردونه.   
    //این کل کد قرارداد است، نه فقط تابع یا بخش خاصی که الان در حال اجراست.
    //وقتی داخل یک تابع هستی، CODESIZE اندازه کل کد قرارداد را می‌داند، نه فقط آن تابع.
    let size := codesize()




    //کپی کردن کال دیتا 
    CALLDATACOPY()
    calldatacopy(0x00, 0x04, 32) // کپی آرگومان اول (از offset 0x04) به مموری آدرس 0
/*
0x00 → آدرس مقصد در حافظه () که می‌خوای کپی کنی

0x04 → آدرس مبدا در  (داده‌های ورودی تابع)

32 → تعداد بایت که می‌خوای کپی کنی
*/



    CODECOPY (0x39)
    //کپی کردن بخشی از کد قرارداد به حافظه
    codecopy(0x00, 0x00, codesize()) // کل کد رو بریز تو memory
/*
0x00 → آدرس شروع در حافظه () که میخوای داده بریزی

0x00 → آدرس شروع در کد قرارداد () که میخوای از اونجا کپی کنی

codesize() → اندازه کل کد قرارداد
*/




    GASPRICE (0x3a)
    //مقدار قیمت گس (گس قیمت ) که فرستنده تراکنش پرداخت می‌کند را می‌دهد.
    let price := gasprice()






    EXTCODESIZE ()
    //طول کد یک آدرس خارجی (حساب یا قرارداد) را برمی‌گرداند
    //سایز کد یک آدرس مشخص (بیرون از کانترکت فعلی). خیلی مفیده برای
    let target := 0x1234567890abcdef1234567890abcdef12345678
    let size := extcodesize(target)




    RETURNDATASIZE()
    //    // اندازه داده برگشتی را می‌گیریم
    let retSize := returndatasize()




// هش بلاک رو برمیگردونه
    BLOCKHASH()
    let blockHashValue := blockhash(blockNum)







    COINBASE 
    let miner := coinbase()
    //آدرس استخراج‌کننده یا ماینر بلاک فعلی را می‌دهد.


    TIMESTAMP  
    //تایم استمپ الان 
    let time := timestamp()



    PREVRANDAO  
    //مقدار  (یک عدد شبه‌تصادفی از بلاک قبلی) را می‌دهد.
    let randaoValue := prevrandao()


    CHAINID 
    //شناسه شبکه ( ) بلاکچین فعلی را برمی‌گرداند
    let currentChainId := chainid()



SSTORE (0x55)
//ذخیره سازی دائمی 
// 32 بایتی را در storage ذخیره می‌کند.
    let key := 0x0
    let value := 42
    sstore(key, value)






SLOAD (0x54)
//خواندن داده از حافظه دائمی
    let key := 0x0
    let value := sload(key)








MSTORE (0x52)
//وظیفه: نوشتن داده 32 بایتی در حافظه
    let offset := 0x0
    let value := 1234
    mstore(offset, value)






MSTORE8()
// نوشتن فقط یک بایت در حافظه
//یک داده 8 بیتی رو مینویسد در حافظه
    let offset := 0x0//افست یعنی محل ذخیره سازی
    let value := 0xff  // 255
    mstore8(offset, value)



MLOAD (0x51)
//خواندن داده 32 بایتی از حافظه 
    let offset := 0x0
    let value := mload(offset)


POP (0x50)
//حذف کردن داده بالا از استک
//آخرین داده موجود در بالای پشته (stack) را حذف می‌کند
    pop()

BLOBBASEFEE (0x4a)
//مقدار base fee  فعلی
    let baseFeeValue := basefee()



BASEFEE (0x48)
//خروجی: حداقل هزینه پایه گس بلوک فعلی



SELFBALANCE (0x47)
//وظیفه: موجودی اتر قرارداد فعلی را برمی‌گرداند.
    let balanceOfSelf := selfbalance()







GASLIMIT (0x45)
//وظیفه: محدودیت گس در بلوک فعلی.
    let gasLimitValue := gaslimit()







    NUMBER (0x43)
    //وظیفه: شماره بلوک فعلی بلاکچین را می‌دهد.    
    let currentBlockNumber := number()





//برنامه را به آدرسی در حافظه که روی پشته قرار دارد منتقل می‌کند
JUMP()
    let dest := 0x80
    // پشته را مقدار می‌گذاریم و جهش می‌کنیم
    push1(dest)
    jump()




JUMPI()
// اگر شرط روی پشته درست باشد پرش انجام می‌شود.
    let dest := 0x80
    let condition := 1  // فرض کنیم شرط true است
    push1(dest)
    push1(condition)
    jumpi() 

/*
اگر condition برابر 1 باشد → پرش انجام می‌شود.
اگر condition برابر 0 باشد → پرش انجام نمی‌شود و اجرای کد ادامه پیدا می‌کند.

این متد خودش به تنهایی استفاده نمیشود      jumpi() 
 باید قبلش این ها  مشخص شده باشد 
 حتماً باید شرط رو خودت آماده کنی و روی استک بذاری



 
1️⃣ آدرس مقصد رو آماده کن و push کن.
2️⃣ شرط رو آماده کن و push کن.
*/






    EXTCODECOPY (0x3c)
    //وظیفه: کپی کردن بخشی از کد قرارداد یا حساب دیگر به حافظه.
    //یک آدرس حساب را به حافظه کپی می‌کند.
    let target := 0x1234567890abcdef1234567890abcdef12345678  // آدرس قرارداد هدف
    let destOffset := 0x0
    let offset := 0x0
    let size := 0x20  // 32 بایت اول کد قرارداد
    



    // کپی کد قرارداد به حافظه
    extcodecopy(target, destOffset, offset, size)





    PC()
//ادرس دستور در ححال اجرا را برمیگردانند




    MSIZE()
    //اندازه حافظه فعال () در بایت را برمی‌گرداند
    let memSize := msize()






    EXTCODEHASH()
    // هش کد قرارداد موجود در آدرس داده شده را برمی‌گرداند. 
    let target := 0x1234567890abcdef1234567890abcdef12345678
    let codeHash := extcodehash(target)







    // مقدار گس باقی مانده در زمان دستور 
    GAS()
        let gasLeft := gas()






JUMPDEST
//یک نشانه معتبر برای پرش‌ها () مشخص می‌کند.
//یعنی هر آدرسی که بخواهیم به آن پرش کنیم باید JUMPDEST باشد.
    jumpdest





//مقدار 32 بایت رو از ذخیرهسازی موقت میخواند 
    TLOAD 
     let key := 0x0
    let value := tload(key)




// مقدار 32 بایت رودر ذخیره سازی موقت مینویسد
    TSTORE 

    let key := 0x0
    let value := 55
    tstore(key, value)




    MCOPY 
    //کپی کردن بلوک حافظه از یک offset به offset دیگر در حافظه.

    let destOffset := 0x40
    let srcOffset := 0x0
    let size := 32
    mcopy(destOffset, srcOffset, size)




    PUSH0 
    //مقدار صفر (0) را روی پشته قرار می‌دهد.
    push0()

     push1(0x7f)
    //یک بایت مقدار ثابت را روی پشته قرار می‌دهد.

    push2(0x7f)
    //دو بایت مقدار ثابت را روی پشته قرار می‌دهد.





    SWAP1 
// ✅ کارش جابجا کردن آیتم‌های استک است.
/*
در ای وی ام یک استک (stack) داریم که می‌تونه تا 1024 مقدار رو نگه داره. دستورات ایویام با استک کار می‌کنن:

    مقادیر رو PUSH می‌کنی.

    مقادیر رو POP می‌کنی.

    مقادیر رو با SWAP جابجا می‌کنی.



| دستور    | چه آیتم‌هایی را جابجا می‌کند |
| -------- | ---------------------------- |
| `SWAP1| آیتم ۱ با آیتم ۲             |
| `SWAP2| آیتم ۱ با آیتم ۳             |
| `SWAP3| آیتم ۱ با آیتم ۴             |
| ...      | ...                          |
| `SWAP16| آیتم ۱ با آیتم ۱۷            |


*/
    //کاربرد این این شکلیه 
    let x := 10
    let y := 20
    // اینجا swap فرضی انجام می‌دیم:
    let temp := x
    x := y
    y := temp
    // حالا x=20 و y=10 است







// برای لاگ گرفتن است همین 
    LOG0 یا 
    LOG1 یا 
    LOG15

    let dataOffset := 0x0
    let dataSize := 64
    let topic1 := 0x1234
    let topic2 := 0x5678

    log2(dataOffset, dataSize, topic1, topic2)
    //مثال دیگر 
    // دو تاپیک (موضوع) برای لاگ
    let topic1 := 0x1111
    let topic2 := 0x2222

    log2(dataOffset, dataSize, topic1, topic2)











CREATE
// یان هم قرار داد میسازد ولی ادرس آن قابل پیش بینی نیست 
// ایجاد قرارداد هوشمند جدید با کد مشخص شده در حافظه.
  let codeOffset := 0x0
    let codeSize := 0x100
    let value := 0
// value: مقدار اتری که در هنگام ایجاد ارسال می‌شود
// offset: آدرس شروع کد در حافظه
// size: طول کد
//مثال 
    let newContract := create(value, codeOffset, codeSize)

    // فرض کن کد قرارداد جدید از قبل تو حافظه ذخیره شده (مثلاً offset=0, size=100)
    let codeOffset := 0x0
    let codeSize := 100
    let value := 0

    // ساخت قرارداد جدید و گرفتن آدرس آن
    let newContract := create(value, codeOffset, codeSize)

    // بررسی اینکه ساخت موفق بوده یا نه
    if iszero(newContract) {
        revert(0, 0)
    }





// فرق create   با    create2
//  فقط در creat2 ادرس قابل پیش بینی است 
// در create  اردس قابل پیش بینی نیست 

    CALL
//ارسال اتر و فراخوانی تابع از یک قرارداد دیگر استفاده می‌شود.
/*

انتقال اتر به آدرس قرارداد یا حساب

فراخوانی توابع قرارداد دیگر

امکان ارسال داده (input data) به قرارداد مقصد

امکان دریافت خروجی (return data) از قرارداد مقصد
*/
// فراخوانی تابع یا انتقال ارزش به آدرس دیگر.
        gas: مقدار گس مجاز برای این کال

        address: آدرس مقصد

        value: مقدار اتری ارسال شده

        argsOffset, argsSize: محل و اندازه داده‌های ورودی (کال)

        retOffset, retSize: محل و اندازه حافظه برای داده برگشتی

    خروجی: موفقیت یا شکست کال (bool)

    // پارامترهای ورودی برای call:
    let gasLimit := gas()
    let to := 0x1234567890123456789012345678901234567890
    let value := 0

    // داده ورودی: فرضاً تو حافظه offset=0, size=32
    let argsOffset := 0x0
    let argsSize := 32

    // محل ذخیره خروجی در حافظه
    let retOffset := 0x0
    let retSize := 32

    // انجام call
    let success := call(gasLimit, to, value, argsOffset, argsSize, retOffset, retSize)

    // بررسی موفقیت
    if iszero(success) {
        revert(0, 0)
    }












    CALLCODE
    //مشابه کال ولی کد را از آدرس دیگر اجرا می‌کند اما اطلاعات فرستنده  و مقدار  قرارداد فعلی حفظ می‌شود (deprecated به سمت DELEGATECALL). 
//خیلی شبیه دلیکت کال است 
/*
الان کمتر استفاده می‌شود چون ناامن‌تر است
مقدار اتر (msg.value) قرارداد فراخواننده است
msg.sender قرارداد فراخواننده است
قدیمی‌تر و قبل از DELEGATECALL

هر دو اجازه می‌دهند قرارداد کد قرارداد دیگری را در 


ولی دلیکیت کال  بهتر است چون ام ای جی سندر و اماس جی ولیو اصلی را حفظ می‌کند (مثل قرارداد پروکسی). خود اجرا کند.


CALLCODE قدیمی است و رفتار متفاوتی در ارسال اطلاعات دارد.
*/





    RETURN  
// اجرای قرارداد را متوقف و داده‌های برگشتی را باز می‌گرداند.

return(چه مقدار بخونی ,  از چه ادرس)     

return(0x00, 32)       // سی دو  بایت از آدرس صفر   رو برگردون 









    DELEGATECALL 
//اجازه می‌دهد قراردادها کد قرارداد دیگر را اجرا کنند ولی رفتار فرستنده و مقدار حفظ شود.
// یعنی تماس با قرار داد دیگر و ثبت تغیرات آن در حافظه این قرار داد 
let success := delegatecall(gas(), target, 0x00, 0x00, 0x00, 0x00)
// اما همه تغییرات ذخیره‌سازی (storage)، متغیرها، و context مربوط به قرارداد فراخواننده (caller) است، نه قرارداد مقصد!
delegatecall(gas, address, in_offset, in_size, out_offset, out_size)
/*
| ورودی        | معنی و کاربرد                                                                                               |
| ------------ | ----------------------------------------------------------------------------------------------------------- |
| `gas`        | مقدار گاز (Gas) تخصیص داده شده برای اجرای فراخوانی. یعنی چقدر منابع محاسباتی اجازه داری مصرف کنی.           |
| `address`    | آدرس قرارداد مقصد که می‌خوای کدش رو اجرا کنی (ولی تغییرات در قرارداد فراخواننده ثبت میشه).                  |
| `in_offset`  | آدرس شروع داده‌های ورودی  در حافظه (مموری) قرارداد فراخواننده که به قرارداد مقصد ارسال می‌شود. |
| `in_size`    | اندازه داده‌های ورودی به بایت (چند بایت از حافظه شروع شده از `in_offset` ارسال شود).                        |
| `out_offset` | آدرس شروع جایی در حافظه که خروجی اجرای قرارداد مقصد باید نوشته شود.                                         |
| `out_size`   | اندازه فضای حافظه برای خروجی .                                        |


*/








    INVALID 
    //دستور نامعتبر، اجرای قرارداد را متوقف می‌کند و خطا ایجاد می‌کند.

/*
اجرای این دستور باعث revert فوری قرارداد میشه

مثل اینه که کدی غیرمجاز اجرا شده باشه و قرارداد متوقف میشه.
*/





    
    SELFDESTRUCT  
    ///حذف قرارداد از بلاک‌چین و ارسال تمام اتری‌های قرارداد به آدرس مشخص شده.
   // آدرس گیرنده اتر
    let recipient := 0xabcdefabcdefabcdefabcdefabcdefabcdefabcd

    selfdestruct(recipient)








    REVERT 
    //اجرای قرارداد را متوقف می‌کند و وضعیت را به قبل باز می‌گرداند

    let errOffset := 0x0
    let errSize := 32

    // ذخیره پیغام خطا در حافظه
    mstore(errOffset, 0xdeadbeef)

    // برگرداندن خطا و لغو تراکنش
    revert(errOffset, errSize)







    CREATE2 
    //ایجاد قرارداد جدید در آدرسی قابل پیش‌بینی (با salt).
}
    let deployedAddress := create2(value, offset, size, salt)
    
    //value مقداری که به قرار داد جدید میخاهیم بفرستیم 
    // آدرس حافظه‌ای که کد بایت‌کد قرارداد از آنجا شروع می‌شود.
    // اندازه بایت‌کد قرارداد  .
    // مقدار ۳۲ بایتی که به‌عنوان ورودی salt برای محاسبه آدرس استفاده می‌شود.






// تعریف SALT

// یک مقدار ۳۲ بایتی (معمولاً هش یا عدد دلخواه) است که همراه با کد قرارداد و آدرس سازنده برای تولید آدرس قرارداد جدید استفاده می‌شود.
/*

 فرمول تولید آدرس:

آدرس قرارداد جدید با فرمول زیر (بسته به پیاده‌سازی EVM) تولید می‌شود:

keccak256(0xFF ++ deployer_address ++ salt ++ keccak256(bytecode)))[12:]

    ++ یعنی الحاق داده‌ها

    [12:] یعنی ۱۲ بایت اول حذف می‌شود و ۲۰ بایت بعدی آدرس است
*/






{
    let ptr := mload(0x40)
    // بایت‌کد را در ptr بنویس
    // mstore(ptr, size)
    // mstore(add(ptr, 0x20), code)

    let addr := create2(0, add(ptr, 0x20), size, salt)
    if iszero(addr) { revert(0, 0) }
}








